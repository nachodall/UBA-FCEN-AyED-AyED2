TAD Elemento es T 
TAD Tiempo es float 
TAD Espacio es float
a)
TAD CacheTTL{ #Hay que agregar algo como Cache<K,V>?
    Observadores{
        memoria: Seq<Elemento x Tiempo>
        timeOut: float #esta bien??
    }

    Operaciones{
        proc crearCache():CacheTTL{
            Requiere:{True}
            asegura:{res.memoria = {}}
        }

        proc agregarItem(inout c:CacheTTL, in e:Elemento){
            requiere:{True}
            asegura:{|c| = |old(c)|+1}
            asegura:{c.memoria = old(c).memoria + [e,0]} #al agregar un item arranca con tiempo = 0
        }

        proc borrarElems(inout c:CacheTTL){ #no puedo usar para todo con Dict???
            requiere:{True}
            asegura:{forall i:int :: 0<=i<|c.memoria| ==>L 
                     If c.memoria[i]_1 = timeOut Then
                        c.memoria = subseq(old(c).memoria,0,i-1) + 
                                    subseq(old(c).memoria,i+1,old(c).memoria.length-1) && |c.memo| = |old(c).memo|
                    Else 
                        c.memoria = old(c).memoria Fi}
        }
    }
}

b)
TAD CacheFIFO{
    Observadores{
        memoria: Conj<Elemento x Espacio x Tiempo>
        espacio: float
    }

    Operaciones{
        proc crearCache():CacheFIFO{
            requiere:{}
            asegura:{CacheFIFO.memoria = []}
        }

        proc agregarElemento(inout c: CacheFIFO, in e: Elemento x Espacio X Tiempo){
            requiere:{!(sinEspacio(c + {e_0,e_1,0}))}
            asegura:{|c.memoria| = |old(c).memoria|+1}
            asegura:{e_2 = 0} #timer en 0
            asegura:{c.memoria = old(c).memoria + {e}}
            asegura:{forall i:int :: 0<=i<|old(c).memoria| ==>L old(c).memoria[i] in c.memoria}
        }

        proc liberarEspacio(inout c: CacheFIFO){ #no se puede hacer un proc liberar espacio q te saque todos los necesarios??
            requiere:{sinEspacio(c)}
            asegura:{c.memoria.length = old(c).memoria.length - 1}
            asegura:{exists i:int :: 0<=i<|old(c).memoria| &&L esEliminado(old.(c).memoria[i], old(c)) &&
                                     !(old(c).memoria[i] in c.memoria)}
            asegura:{forall i:int :: 0<=i<|old(c).memoria| && !Eliminado(old(c).memoria[i], old(c)) ==>L 
                                     old(c).memoria[i] in c.memoria}                                     
        }

        pred sinEspacio(c: CacheFIFO){
            res = True <==> (sum i:int :: 0<=i<c.memoria.length :: c.memoria[i]_1) >= espacio
        }

        pred esEliminado(e: Elemento X Espacio X Tiempo, c: CacheFIFO){
            res = True <==> !exists i:int :: 0<=i<|c.memoria| &&L c.memoria[i]_2 > e_2
        }
    }
}