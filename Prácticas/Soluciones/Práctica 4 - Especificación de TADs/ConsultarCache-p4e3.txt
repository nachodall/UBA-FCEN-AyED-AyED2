a) 
TAD CacheTTL<K,V>{
    obs memoria: Dict<clave: K, datos: struct<value: V, time: real>>
    obs timeOut: real

    proc borrarAutomaticamente(inout c: CacheTTL<K,V>)
        Requiere: exists e: K :: e in c.memoria && c.memoria[e].time = c.timeOut
        Requiere: c == old(c)
        Asegura: c.timeOut = old(c).timeOut
        Asegura: sinElementosVencidos(c)
        Asegura: forall k: K :: (k in old(c).memoria && old(c).memoria[k].time < c.timeOut) ==> k in c.memoria
        Asegura: forall k: K :: k in c.memoria ==> k in old(c).memoria

    pred sinElementosVencidos(c: CacheTTL<K,V>)
        ! (exists k: K :: k in c.memoria && c.memoria[k].time >= c.timeOut)

    proc agregarElemento(inout c: CacheTTL<K,V>, in k: K, in v: V)
        Requiere: !(k in c.memoria)
        Requiere: c == old(c)
        Asegura: c.memoria = setKey(c.memoria, k, <V, 0>)
        Asegura: c.timeOut = old(c).timeOut

    proc pasaTiempo(inout c: CacheTTL<K,V>, in t: real)
        Requiere: c == old(c) && t < c.timeOut
        Asegura: forall k: K :: k in c.memoria ==> c.memoria[k].time = c.memoria[k].time + t
        Asegura: c.timeOut = old(c).timeOut
        Asegura: forall k: K :: k in c.memoria <==> k in old(c).memoria

    proc accederAElemento(inout c: CacheTTL<K,V>, in k: K)
        Requiere: k in c.memoria && c == old(C)
        Asegura: c.memoria = old(c).memoria
        Asegura: c.timeOut = old(c).timeOut
}

b)
TAD CacheFIFO<K,V>{
    obs memoria: Dict<clave: K, datos: struct<value: V, time: real>>
    obs capacidadMax: int

    proc borrarAutomaticamente(inout c: CacheFIFO<K,V>)
        Requiere: cantClaves(c.memoria) >= c.capacidadMax
        Requiere: c == old(c)
        Asegura: c.capacidadMax = old(c).capacidadMax
        Asegura: exists k: K :: k in old(c).memoria && 
                 (forall k': K :: k' in old(c)memoria && k!=k' ==> c.memoria[k].time >= c.memoria[k'].time && k' in c.memoria) &&
                 !(k in c.memoria)
        Asegura: forall k :: K in c.memoria ==> k in old(c).memoria

    proc agregarElemento(inout c: CacheTTL<K,V>, in k: K, in v: V)
        Requiere: !(k in c.memoria)
        Requiere: c == old(c)
        Asegura: c.capacidadMax = old(c).capacidadMax
        Asegura: c.memoria = setKey(c.memoria, k, <V, 0>)

    proc pasaTiempo(inout c: CacheTTL<K,V>, in t: real)
        Requiere: c == old(c)
        Asegura: forall k: K :: k in c.memoria ==> c.memoria[k].time = c.memoria[k].time + t
        Asegura: c.capacidadMax = old(c).capacidadMax
        Asegura: forall k: K :: k in c.memoria <==> k in old(c).memoria

    proc accederAElemento(inout c: CacheTTL<K,V>, in k: K)
        Requiere: k in c.memoria && c == old(C)
        Asegura: c.memoria = old(c).memoria
        Asegura: c.capacidadMax = old(c).capacidadMax
}

c)
TAD CacheLRU<K,V>{
    obs memoria: Dict<clave: K, datos: struct<value: V, time: real>>
    obs capacidadMax: int

    proc borrarAutomaticamente(inout c: CacheFIFO<K,V>)
        Requiere: cantClaves(c.memoria) >= c.capacidadMax
        Requiere: c == old(c)
        Asegura: c.capacidadMax = old(c).capacidadMax
        Asegura: exists k: K :: k in old(c).memoria && 
                 (forall k': K :: k' in old(c)memoria && k!=k' ==> c.memoria[k].time >= c.memoria[k'].time && k' in c.memoria) &&
                 !(k in c.memoria)
        Asegura: forall k :: K in c.memoria ==> k in old(c).memoria

    proc agregarElemento(inout c: CacheTTL<K,V>, in k: K, in v: V)
        Requiere: !(k in c.memoria)
        Requiere: c == old(c)
        Asegura: c.capacidadMax = old(c).capacidadMax
        Asegura: c.memoria = setKey(c.memoria, k, <V, 0>)

    proc accederAElemento(inout c: CacheTTL<K,V>, in k: K)
        Requiere: k in c.memoria && c == old(C)
        Asegura: c.memoria = setKey(c.memoria, k, <old(c).memoria[k].value, 0>)
        Asegura: c.capacidadMax = old(c).capacidadMax

    proc pasaTiempo(inout c: CacheTTL<K,V>, in t: real)
        Requiere: c == old(c)
        Asegura: forall k: K :: k in c.memoria ==> c.memoria[k].time = c.memoria[k].time + t
        Asegura: c.capacidadMax = old(c).capacidadMax
        Asegura: forall k: K :: k in c.memoria <==> k in old(c).memoria
}